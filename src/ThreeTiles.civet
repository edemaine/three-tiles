solid-js import { createMemo, type JSX }
operator { max } := Math

./Tile.civet import { type Prototile }
./Turtle.civet import { Turtle, cos, sin }

l := 1.5
eps2 := 5
eps3 := 5
eps1 := eps2 + eps3

function staple(t: Turtle): Turtle
  t
  //.f l * (2 - cos(eps3) + sin(eps1))
  .l 90 + eps1
  .f l
  .r 90 + eps2
  .f l
  .r 90 + eps3
  .f 2 * l * (cos(eps1) + sin(eps3))
  .r 90 + eps3
  .f l
  // Closing:
  //.r 90 + eps2
  //.f l

function tweedledee(t: Turtle): Turtle
  t
  .f l * (2 - cos(eps3) + sin(eps1))
  .l 90 + eps1
  .f l
  .r 90 + eps2
  .f l
  .r 90 + eps3
  .f 2 * l * (cos(eps1) + sin(eps3))
  .l 90 + eps3
  .f l
  .l 90 + eps2
  .f l
  .r 90 + eps1
  .f l * (2 - cos(eps3) + sin(eps1))

function tweedledum(t: Turtle): Turtle
  t
  .f l * (2 - cos(eps3) + sin(eps1))
  .r 90 + eps1
  .f l
  .l 90 + eps2
  .f l
  .l 90 + eps3
  .f 2 * l * (cos(eps1) + sin(eps3))
  .r 90 + eps3
  .f l
  .r 90 + eps2
  .f l
  .l 90 + eps1
  .f l * (2 - cos(eps3) + sin(eps1))

aroundGlueGap := 6*l
midGlueGap := 1.5*l
//aroundGlueGap := 5*l
//midGlueGap := 4*l

function wheel(t: Turtle, tiles: Prototile[], nBits: number): Turtle
  function glue(g: number)
    bitString .=
    Math.abs(g) - 1 // map positive/negative glue to nonnegative color
    |> .toString 2  // binary representation
    |> .padStart nBits, '0' // exactly nBits long
    // Convert string to array of numbers
    bits := for each bit of bitString
      Number bit
    if g > 0
      bits.unshift 0, 0
      bits.push 0, 1
    else
      bits.unshift 1, 0
      bits.push 0, 0
    t.f aroundGlueGap
    for each bit, i of bits
      t.f midGlueGap unless i is 0
      if bit is 0
        tweedledee t
      else // bit is 1
        tweedledum t
    t.f aroundGlueGap

  for each dir of ['n', 'e', 's', 'w'] as const
    for each tile of tiles
      glue tile[dir]
      t.r 90 / tiles#
  t

function notch(t: Turtle): Turtle
  t
  .f l * (2 - cos(eps3) + sin(eps1))
  .l (90 + eps1)
  .f l
  .r 90 + eps2
  .f l
  .r 2 * eps3
  .f l
  .r 90 + eps2
  .f l
  .l 90 + eps1
  .f l * (2 - cos(eps3) + sin(eps1))

function shuriken(t: Turtle, nTiles: number, nBits: number): Turtle
  for [1..4] // directions
    for i of [2..nTiles]
      t
      .r 90 / nTiles
      .f aroundGlueGap
      for each i of [0...nBits + 4] // 4 to compensate for padding
        t.f midGlueGap unless i is 0
        notch t
      t.f aroundGlueGap
    t.l 180 - 90 / nTiles
  t

function ceilLog2(glues: number): number
  nBits .= 1
  maxVal .= 2
  while maxVal < glues
    nBits++
    maxVal <<= 1
  nBits

function unsignedToSigned(tiles: Prototile[], glues: number): {tiles: Prototile[], glues: number}
  // Remove aliasing
  tiles = for each tile of tiles
    {...tile}
  // Glues wrap around
  for each tile of tiles
    tile.w %%= glues
    tile.e %%= glues
    tile.s %%= glues
    tile.n %%= glues
  // Remove overlap from horizontal and vertical glues
  hGlues := new Set (tile.w for each tile of tiles) ++
                    (tile.e for each tile of tiles)
  vGlues := new Set (tile.n for each tile of tiles) ++
                    (tile.s for each tile of tiles)
  maxGlue .= for max glue of hGlues.union vGlues
  for glue of hGlues.intersection vGlues
    // Map glue -> maxGlue (new glue number)
    maxGlue++
    for each tile of tiles
      tile.w = maxGlue if tile.w is glue
      tile.e = maxGlue if tile.e is glue
  glues max= maxGlue + 1
  // Sign glues, and avoid zero, because -0 is messy
  for each tile of tiles
    tile.w = -(tile.w + 1)
    tile.e = +(tile.e + 1)
    tile.s = -(tile.s + 1)
    tile.n = +(tile.n + 1)
  {tiles, glues}

margin := 1
tileGap := 3 * l
export function ThreeTiles(props: {tiles: Prototile[], glues: number, zoom: number})
  createMemo =>
    {tiles, glues} .= unsignedToSigned props.tiles, props.glues
    nBits := ceilLog2 glues
    staplePoly := new Turtle |> staple |> .shift()
    wheelPoly := new Turtle |> wheel ., tiles, nBits
    |> .shift() //staplePoly.maxX() + tileGap
    shurikenPoly := new Turtle |> shuriken ., tiles#, nBits
    |> .shift()
    shurikenPoly.shift
      wheelPoly.maxX() - shurikenPoly.maxX()/2 - l * (cos(eps1) + sin(eps3))
      wheelPoly.maxY() - shurikenPoly.maxY()/2 - l * (cos(eps1) + sin(eps3))
    <svg viewBox=`${-margin} ${-margin} ${shurikenPoly.maxX() + 2*margin} ${shurikenPoly.maxY() + 2*margin}` width=`${props.zoom*100}%`>
      <polygon .ptile points=staplePoly.toPolygonString() fill="yellow">
      <polygon .ptile points=wheelPoly.toPolygonString() fill="#9142c3">
      <polygon .ptile points=shurikenPoly.toPolygonString() fill="green">
  as! JSX.Element
